// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package sqlcqueries

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createCourse = `-- name: CreateCourse :one

INSERT INTO courses (
    user_id,
    course_name,
    total_points_possible
) VALUES (
    $1,
    $2,
    $3
)
RETURNING course_id, user_id, course_name, total_points_possible, created_at, updated_at
`

type CreateCourseParams struct {
	UserID              uuid.UUID `json:"user_id"`
	CourseName          string    `json:"course_name"`
	TotalPointsPossible int32     `json:"total_points_possible"`
}

// =============================================
// Courses
// =============================================
func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) (*Course, error) {
	row := q.db.QueryRow(ctx, createCourse, arg.UserID, arg.CourseName, arg.TotalPointsPossible)
	var i Course
	err := row.Scan(
		&i.CourseID,
		&i.UserID,
		&i.CourseName,
		&i.TotalPointsPossible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createTask = `-- name: CreateTask :one

INSERT INTO tasks (
    course_id,
    title,
    due_date,
    points_value
    -- status defaults to 'in_progress'
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING task_id, course_id, title, due_date, points_value, status, created_at, updated_at
`

type CreateTaskParams struct {
	CourseID    int32     `json:"course_id"`
	Title       string    `json:"title"`
	DueDate     time.Time `json:"due_date"`
	PointsValue int32     `json:"points_value"`
}

// =============================================
// Tasks
// =============================================
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (*Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.CourseID,
		arg.Title,
		arg.DueDate,
		arg.PointsValue,
	)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.CourseID,
		&i.Title,
		&i.DueDate,
		&i.PointsValue,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUser = `-- name: CreateUser :one


INSERT INTO users (
    email,
    password_hash
) VALUES (
    $1,
    $2
)
RETURNING user_id, email, password_hash, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

// query.sql
// =============================================
// Users
// =============================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteCourse = `-- name: DeleteCourse :exec
DELETE FROM courses
WHERE course_id = $1 AND user_id = $2
`

type DeleteCourseParams struct {
	CourseID int32     `json:"course_id"`
	UserID   uuid.UUID `json:"user_id"`
}

// Deletes a course only if it belongs to the specified user
func (q *Queries) DeleteCourse(ctx context.Context, arg DeleteCourseParams) error {
	_, err := q.db.Exec(ctx, deleteCourse, arg.CourseID, arg.UserID)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks
WHERE task_id = $1
`

type DeleteTaskParams struct {
	TaskID int32 `json:"task_id"`
}

// Deletes a specific task. Ownership should be checked first.
func (q *Queries) DeleteTask(ctx context.Context, arg DeleteTaskParams) error {
	_, err := q.db.Exec(ctx, deleteTask, arg.TaskID)
	return err
}

const getCourseByID = `-- name: GetCourseByID :one
SELECT course_id, user_id, course_name, total_points_possible, created_at, updated_at FROM courses
WHERE course_id = $1 AND user_id = $2
LIMIT 1
`

type GetCourseByIDParams struct {
	CourseID int32     `json:"course_id"`
	UserID   uuid.UUID `json:"user_id"`
}

// Fetch a specific course only if it belongs to the specified user
func (q *Queries) GetCourseByID(ctx context.Context, arg GetCourseByIDParams) (*Course, error) {
	row := q.db.QueryRow(ctx, getCourseByID, arg.CourseID, arg.UserID)
	var i Course
	err := row.Scan(
		&i.CourseID,
		&i.UserID,
		&i.CourseName,
		&i.TotalPointsPossible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getEarnedPointsForCourse = `-- name: GetEarnedPointsForCourse :one

SELECT COALESCE(SUM(points_value), 0)::INTEGER AS earned_points
FROM tasks
WHERE course_id = $1 AND status = 'done'
`

type GetEarnedPointsForCourseParams struct {
	CourseID int32 `json:"course_id"`
}

// =============================================
// Progress & Reminders
// =============================================
// Calculates the sum of points for tasks marked 'done' for a specific course.
// Ownership must be verified in application logic before calling this.
func (q *Queries) GetEarnedPointsForCourse(ctx context.Context, arg GetEarnedPointsForCourseParams) (int32, error) {
	row := q.db.QueryRow(ctx, getEarnedPointsForCourse, arg.CourseID)
	var earned_points int32
	err := row.Scan(&earned_points)
	return earned_points, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT task_id, course_id, title, due_date, points_value, status, created_at, updated_at FROM tasks
WHERE task_id = $1
LIMIT 1
`

type GetTaskByIDParams struct {
	TaskID int32 `json:"task_id"`
}

// Fetches a single task by its ID. Ownership should be checked in application logic
// by verifying the associated course_id belongs to the user.
func (q *Queries) GetTaskByID(ctx context.Context, arg GetTaskByIDParams) (*Task, error) {
	row := q.db.QueryRow(ctx, getTaskByID, arg.TaskID)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.CourseID,
		&i.Title,
		&i.DueDate,
		&i.PointsValue,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, email, password_hash, created_at, updated_at FROM users
WHERE email = $1
LIMIT 1
`

type GetUserByEmailParams struct {
	Email string `json:"email"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, arg.Email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, email, password_hash, created_at, updated_at FROM users
WHERE user_id = $1
LIMIT 1
`

type GetUserByIDParams struct {
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetUserByID(ctx context.Context, arg GetUserByIDParams) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, arg.UserID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listCoursesByUser = `-- name: ListCoursesByUser :many
SELECT course_id, user_id, course_name, total_points_possible, created_at, updated_at FROM courses
WHERE user_id = $1
ORDER BY created_at DESC
`

type ListCoursesByUserParams struct {
	UserID uuid.UUID `json:"user_id"`
}

// Lists all courses belonging to a specific user
func (q *Queries) ListCoursesByUser(ctx context.Context, arg ListCoursesByUserParams) ([]*Course, error) {
	rows, err := q.db.Query(ctx, listCoursesByUser, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.CourseID,
			&i.UserID,
			&i.CourseName,
			&i.TotalPointsPossible,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesWithEarnedPoints = `-- name: ListCoursesWithEarnedPoints :many
SELECT
    c.course_id,
    c.user_id,
    c.course_name,
    c.total_points_possible,
    c.created_at,
    c.updated_at,
    COALESCE(SUM(CASE WHEN t.status = 'done' THEN t.points_value ELSE 0 END), 0)::INTEGER AS earned_points
FROM courses c
LEFT JOIN tasks t ON c.course_id = t.course_id
WHERE c.user_id = $1
GROUP BY c.course_id
ORDER BY c.created_at DESC
`

type ListCoursesWithEarnedPointsParams struct {
	UserID uuid.UUID `json:"user_id"`
}

type ListCoursesWithEarnedPointsRow struct {
	CourseID            int32     `json:"course_id"`
	UserID              uuid.UUID `json:"user_id"`
	CourseName          string    `json:"course_name"`
	TotalPointsPossible int32     `json:"total_points_possible"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
	EarnedPoints        int32     `json:"earned_points"`
}

// Lists all courses for a user along with the total points earned from completed tasks in each course.
func (q *Queries) ListCoursesWithEarnedPoints(ctx context.Context, arg ListCoursesWithEarnedPointsParams) ([]*ListCoursesWithEarnedPointsRow, error) {
	rows, err := q.db.Query(ctx, listCoursesWithEarnedPoints, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListCoursesWithEarnedPointsRow
	for rows.Next() {
		var i ListCoursesWithEarnedPointsRow
		if err := rows.Scan(
			&i.CourseID,
			&i.UserID,
			&i.CourseName,
			&i.TotalPointsPossible,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EarnedPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByCourse = `-- name: ListTasksByCourse :many
SELECT task_id, course_id, title, due_date, points_value, status, created_at, updated_at FROM tasks
WHERE course_id = $1
ORDER BY due_date ASC
`

type ListTasksByCourseParams struct {
	CourseID int32 `json:"course_id"`
}

// Lists all tasks for a specific course, ordered by due date
// Ownership must be verified in application logic before calling this (e.g., ensure the user owns the course_id)
func (q *Queries) ListTasksByCourse(ctx context.Context, arg ListTasksByCourseParams) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasksByCourse, arg.CourseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.TaskID,
			&i.CourseID,
			&i.Title,
			&i.DueDate,
			&i.PointsValue,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingTasksByUser = `-- name: ListUpcomingTasksByUser :many
SELECT
    t.task_id,
    t.course_id,
    t.title,
    t.due_date,
    t.points_value,
    t.status,
    t.created_at,
    t.updated_at,
    c.course_name
FROM tasks t
JOIN courses c ON t.course_id = c.course_id
WHERE
    c.user_id = $1
    AND t.status = 'in_progress'
    AND t.due_date >= NOW()
    AND t.due_date <= $2
ORDER BY t.due_date ASC
`

type ListUpcomingTasksByUserParams struct {
	UserID            uuid.UUID `json:"user_id"`
	UpcomingLimitDate time.Time `json:"upcoming_limit_date"`
}

type ListUpcomingTasksByUserRow struct {
	TaskID      int32      `json:"task_id"`
	CourseID    int32      `json:"course_id"`
	Title       string     `json:"title"`
	DueDate     time.Time  `json:"due_date"`
	PointsValue int32      `json:"points_value"`
	Status      TaskStatus `json:"status"`
	CreatedAt   time.Time  `json:"created_at"`
	UpdatedAt   time.Time  `json:"updated_at"`
	CourseName  string     `json:"course_name"`
}

// Lists tasks that are 'in_progress' and due between now and a specified future date for a given user.
// Includes course name for context.
func (q *Queries) ListUpcomingTasksByUser(ctx context.Context, arg ListUpcomingTasksByUserParams) ([]*ListUpcomingTasksByUserRow, error) {
	rows, err := q.db.Query(ctx, listUpcomingTasksByUser, arg.UserID, arg.UpcomingLimitDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUpcomingTasksByUserRow
	for rows.Next() {
		var i ListUpcomingTasksByUserRow
		if err := rows.Scan(
			&i.TaskID,
			&i.CourseID,
			&i.Title,
			&i.DueDate,
			&i.PointsValue,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CourseName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCourse = `-- name: UpdateCourse :one
UPDATE courses
SET
    course_name = $1,
    total_points_possible = $2
WHERE
    course_id = $3 AND user_id = $4
RETURNING course_id, user_id, course_name, total_points_possible, created_at, updated_at
`

type UpdateCourseParams struct {
	CourseName          string    `json:"course_name"`
	TotalPointsPossible int32     `json:"total_points_possible"`
	CourseID            int32     `json:"course_id"`
	UserID              uuid.UUID `json:"user_id"`
}

// Updates course details, ensuring ownership
func (q *Queries) UpdateCourse(ctx context.Context, arg UpdateCourseParams) (*Course, error) {
	row := q.db.QueryRow(ctx, updateCourse,
		arg.CourseName,
		arg.TotalPointsPossible,
		arg.CourseID,
		arg.UserID,
	)
	var i Course
	err := row.Scan(
		&i.CourseID,
		&i.UserID,
		&i.CourseName,
		&i.TotalPointsPossible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateTaskDetails = `-- name: UpdateTaskDetails :one
UPDATE tasks
SET
    title = $1,
    due_date = $2,
    points_value = $3,
    status = $4
WHERE
    task_id = $5
RETURNING task_id, course_id, title, due_date, points_value, status, created_at, updated_at
`

type UpdateTaskDetailsParams struct {
	Title       string     `json:"title"`
	DueDate     time.Time  `json:"due_date"`
	PointsValue int32      `json:"points_value"`
	Status      TaskStatus `json:"status"`
	TaskID      int32      `json:"task_id"`
}

// Updates details of a specific task. Ownership should be checked first.
func (q *Queries) UpdateTaskDetails(ctx context.Context, arg UpdateTaskDetailsParams) (*Task, error) {
	row := q.db.QueryRow(ctx, updateTaskDetails,
		arg.Title,
		arg.DueDate,
		arg.PointsValue,
		arg.Status,
		arg.TaskID,
	)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.CourseID,
		&i.Title,
		&i.DueDate,
		&i.PointsValue,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET status = $1
WHERE task_id = $2
RETURNING task_id, course_id, title, due_date, points_value, status, created_at, updated_at
`

type UpdateTaskStatusParams struct {
	Status TaskStatus `json:"status"`
	TaskID int32      `json:"task_id"`
}

// Updates the status of a specific task. Ownership should be checked first.
func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (*Task, error) {
	row := q.db.QueryRow(ctx, updateTaskStatus, arg.Status, arg.TaskID)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.CourseID,
		&i.Title,
		&i.DueDate,
		&i.PointsValue,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
